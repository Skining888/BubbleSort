#pragma once
//函数说明：将某一个父节点通过比较左右子节点，交换最大的值为父节点，保证是大堆，即每一个父节点都比子节点大
//			左节点left = 2*i + 1
//			右节点right = 2*i + 2
// 入参：int tree[]，要建成大堆的树地址
//		 int n，树的节点个数
//		 int i，从i的位置进行建堆
//出参：无
void Heappos(int tree[], int n, int i);

//函数说明：根据树的节点个数，通过prent = (n -1) / 2,计算出建大堆的起始父节点位置
// 入参：int tree[]，要建成大堆的树地址
//		 int n，树的节点个数
//出参：无
void CreatHeap(int tree[], int n);

//函数说明：排序建好的大堆，交换根节点和最后一个叶子节点，然后删除最后一个叶子结点，对根节点进行建大堆，如此循环n - 1次，即可排序大堆
// 入参：int tree[]，要建成大堆的树地址
//		 int n，树的节点个数
// 出参：无
void HeapSort(int tree[], int n);


//堆排序总结：
// 中心思想：通过比较父节点和左右子节点，建成父节点一定比左右子节点大的大堆，然后对建成的堆进行排序。即交换根节点和最后一个叶子节点，
// 然后删除最后一个叶子结点，对根节点再次进行建大堆操作，如此执行N - 1次即可完成大堆的排序
// 堆排序的时间复杂度最坏情况为：O（logn）
//堆排序是不稳定的排序